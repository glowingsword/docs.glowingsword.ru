# Journald – система журналирования systemd

## Общие сведения о journald
На серверах с systemd(Centos 7+) логи пишутся по умолчанию в journald(система журналирования systemd). Система журналирования systemd хранит логи в бинарном формате(используется для более эффективного хранения записей в логах), и снабжена собственной системой ротации и очистки логов. Так как логи хранятся в бинарном формате,  для просмотра системных логов и логов отдельных служб следует использовать утилиту journalctl.

## Использование утилиты journalctl для отображения записей из журналов

### Без фильрации(простомотр всех записей)

Запуск 

```bash
journalctl
```

выведет множество сообщений. Они никак не отфильтрованы, ни по времени, ни по названию сервиса, ни по pid приложения/службы. Записей может быть очень много, поэтому лучше следом за journalctl сразу конвейер с grep организовать, для отображения только интересующих нас записей, приерно так

```bash
journalctl|grep sshcom
```

### Фильтрация по id загрузки(с послещней загрузки по текущее время, прыдыдущая сессия(загрузка) и т.п.)

#### Просмотр логов с момента последней загрузки ОС

```bash
journalctl -b
```

#### Просмотр логов предыдущих загрузок

Если в файле ==/etc/systemd/journald.conf== у нас указано

```ini
[Journal]
Storage=persistent
```
то мы можем посмотреть записи за предыдущие загрузки, делается это так

```bash
journalctl -b 0
```

где 0 - id загрузки. 

Для указания нужного id или uuid загрузки в качестве параметра для команды ==journalctl -b== используем команду 

```bash
journalctl --list-boots
```

которая выводит что-то вроде 

```bash
 -7 2b4e7904e159460c8fc1e84a34b45798 Mon 2020-09-07 11:49:23 CEST—Tue 2020-09-08 01:24:30 CEST
 -6 3c8c9b4b8d4c49da87bcc577694b1160 Tue 2020-09-08 13:22:10 CEST—Tue 2020-09-08 19:20:56 CEST
 -5 02e9cb86050c45b6a7be473df74748c3 Tue 2020-09-08 19:21:11 CEST—Wed 2020-09-09 06:44:49 CEST
 -4 9212a8f0fdd54f7aba2ea0163b96c3b9 Wed 2020-09-09 17:31:16 CEST—Thu 2020-09-10 07:45:59 CEST
 -3 4a6efb189d8145afa29d75b5dca8b38d Thu 2020-09-10 14:37:10 CEST—Fri 2020-09-11 01:58:57 CEST
 -2 5fd7f52412c545d18dba639a08b9f162 Fri 2020-09-11 16:45:38 CEST—Fri 2020-09-11 23:18:03 CEST
 -1 3d930e5a820b47bd8c3ee19f7b384cf1 Sat 2020-09-12 11:28:31 CEST—Sat 2020-09-12 23:43:53 CEST
  0 cdd535897bef4019a36d15a50d4cb0cd Sun 2020-09-13 10:46:58 CEST—Sun 2020-09-13 14:13:17 CEST
```

где значения первой колонки(формата numeric) — необходимые нам id предыдущих загрузок. Во второй колонке указаны uuid(в формате alphanumeric) предыдущих загрузок, которые могут быть использованы вместо числовых значений id.


### Фильтрация записей журнала journald по времени и дате

Для вывода логов с конкретного периода времени и по настоящий момент используем команду

```bash
journalctl --since '2020-09-13 14:15:00'
```
где параметр ==--since== указывает на время, начиная с которого journalctl выведет записи.

Если нужно просмотреть логи за период с конкретного времени и по конкретное время(не по настоящий момент), указываем начало интересующего нас периода с помощью параметра ==--since== и окончание нужного нам периода времени, с помощью парамтера ==--until==.

Пример

```bash
journalctl --since '2020-09-13 14:15:00' --until '2020-09-13 14:20:00'
```

Параметры --since и --until довольно гибко трактуются. Если указана только часть значения, недостающая часть дополняется автоматически. Дата дополняется текущей датой, а часы, минуты и секунды - значениями вида 00.

Если в качестве значения --since или --until указать параметры вида:

* 14:15:16 — мы указали время, не указав дату — journalctl все записи с временем без указания даты трактует как сегоднящние записи за указанное время, так как в отсутствие указанной даты время трактуется как сегодняшнее;
* 14:15 — то же, что и в записи выше, только не указаны секунды. Если не указаны секунды, подставляется дефолтное значение, равное ==00==;
* 14  — не указаны и минуты, запись трактуется как 14:00:00, так как не указанные данные дополняются дефолтным ==00:00==;
* 2020-09-13 — указали дату, не указали время: по умолчанию запись трактуется как ==2020-09-13 00:00:00==.

Кроме точного указания временных значений можно указывать естественные для людей относительные значения:

* now - текущий момент времени;
* yesterday – вчера(этот же момент времени - 24 часа);
* yesterday 12:00 — вчера в 12 часов;
* 1 hour ago – один час назад(текущее время - 1 час);
* 1 day ago  – один день назад(текущее время из 24 часа).

### Текущие события(последние записи)

Текущие события(последние 10 записей) можно глянуть командой

```bash
journalctl -n
```
Если нужно больше событий в выхлопе journalctl -n, после параметра -n указываем необходимо нам число событий, к примеру

```bash
journalctl -n 20
```
отобразит последние 20 записей о событиях в системе.

Просмотр логов в режиме реального времени

```bash
journalctl -f 
```

### Фильтрация по приложениям и службам

Для фильтрации по приложениям и службам используем параметр ==-u==.

К примеру

```bash
journalctl -u nginx
```

где nginx – название нужной службы. 

Глянуть название всех включенных на хосте служб можно с помощью команды systemctl, запущенной без параметров, так

```bash
systemctl
```

Также можно фильтровать записи по нескольким службам сразу, к примеру так

```bash
journalctl -u nginx.service -u httpd.service -u httpd2.service
```
и применять дополнительные условия фильтрации по времени, к примеру так

```bash
journalctl -u nginx.service -u httpd.service -u httpd2.service --since '1 hour ago' --until '10 minutes ago'
```

### Фильтрация по процессам, пользователям и группам

#### Фильтрация по PID
Фильтрация по PID(получить pid интересующего нас процесса можно в выводе ps/top/atop/lsof/ss и т.п. в зависимости от ситуации)

```bash
journalctl _PID=1001
```

#### Фильтрация по UID

Фильтрация по UID процесса

```bash
journalctl _UID=48
```
#### Фильтрация по GID процесса

Фильтрация по GID процесса

```bash
journalctl _GID=48
```

### Фильтрация записей по пути

```bash
journalctl /usr/bin/docker
```
### Фильтрация записей по имени приложения, наименованию исполняемого файла и параметрам командной строки

Фильтруем по наименованию приложения

```bash
journalctl _COMM=sshd
```

Фильтруем по пути к бинарнику

```bash
journalctl _EXE=sshd
```

Фильтруем по полной командной строке(путь к бинарнику с указанием интересующих нас параметров)

```bash
journalctl _CMDLINE='/usr/bin/pulseaudio --daemonize=no'
```

### Фильтрация по устройству

```bash
journalctl _KERNEL_DEVICE=+acpi:LNXPOWER:02
```

### Смотрим список доступных значений для параметра фильтрации

journalctl умный, он сам может предложить нам список возможных значений для параметров фильтрации, если его попросить отобразить все доступные значения.

Делается это с помощью параметра -F , так

```bash
journalctl -F <OUR FILTER>
```

Где вместо ==<OUR FILTER>== указываем

* _UID — для отображения списка отметившихся в записях в логах UID пользователей, от имени которых запускалась служба/выполнялось приложение
* _GID — для отображения списка отметившихся в записях в логах GID пользователей, от имени которых запускалась служба/выполнялось приложение
* _COMM — cписок всех отметившихся в логах приложений
* _EXE  — перечисление всех отметившихся в логах путей к исполняемым файлам
* _CMDLINE — перечисление всех отметившихся в логах полных параметров запуска команды(путь к исполняемому файлу с набором параметров командной строки, использованных при запуске)
* _KERNEL_DEVICE — список устройств, отметившихся в логах systemd, по ним можно фильтровать записи, связанные с событиями, порождённым ядром при взаимодействии с железом хоста.

К примеру, список устройств, по которым можно фильтровать записи,  смотрим так

```bash
journalctl -F _KERNEL_DEVICE
```

### Фильтрация записей по значению syslog facility

Сообщения можно фильтровать и по syslog facility.
Ниже представлены несолько примеров наиболее полезных вариантов использования подобной фильтрации.

#### Отображение сообщений из SYSLOG_FACILITY=0 (эквивалент kernel)
journalctl SYSLOG_FACILITY=0

#### Отображение сообщений из SYSLOG_FACILITY=1 (записи из категории user level)
journalctl SYSLOG_FACILITY=1


#### Отображение сообщений из SYSLOG_FACILITY=2 (mail, замена mail.log что был на тачках со старым syslog)
journalctl SYSLOG_FACILITY=2

#### Отображение сообщений из SYSLOG_FACILITY=3 (daemon, записи различных системных служб)
journalctl SYSLOG_FACILITY=3

#### Отображение сообщений из SYSLOG_FACILITY=4 (auth, информация об авторизациях и безопасности – эквивалент auth.log)
journalctl SYSLOG_FACILITY=4

#### Отображение сообщений из SYSLOG_FACILITY=10 (authpriv, информация об авторизациях и безопасности – эквивалент auth.log)
journalctl SYSLOG_FACILITY=10

#### Дополнительная информация

Полную таблицу с числовыми id соответствующих syslog facility можно глянуть на https://wiki.archlinux.org/index.php/Systemd/Journal в разделе Facility, или выполнив команду 

```bash
journalctl --facility=help
```

Вместо длинного SYSLOG_FACILITY нужный уровень facility можно указать в качестве значения параметра --facility.

К примеру, команды

```bash
journalctl --facility=2
```
и

```bash
journalctl SYSLOG_FACILITY=2
```
делают одно и то же.

#### Фильрация записей по регулярке, что проходится по значению поля MESSAGE записей, и возвращает совпадающие с правилами регулярки записи

К примеру, вот это
```bash
journalctl --grep='Xorg.0.log'
```
будет искать записи с упоминанием Xorg.0.log.

К сожалению, параметр -g/--grep добавили в journalctl не так давно, и в Centos 7 данный параметр journalctl не поддерживает. А потому там грепаем по старинке, через конвейер с старым-добрым grep.

### Просмотр сообщений ядра

#### Смотрми сообщения ядра

```bash
journalctl -k
```

#### Смотрми сообщения ядра предыдущих сессий

Сообщения ядра предыдущих загрузки смотрим, комбининуя параметр лога сообщений ядра(-k) с параметром нужной нам сессии(загрузки, параметр -b)

```bash
journalctl -k -b -2
```

#### Фильрация записей по уровню ошибки

```bash
journalctl -p err -b
```

где вместо err в качестве параметра для опции -p можно использовать следующие значения

* 0 — EMERG (система неработоспособна);
* 1 — ALERT (требуется немедленное вмешательство);
* 2 — CRIT (критическое состояние);
* 3 — ERR (ошибка);
* 4 — WARNING (предупреждение);
* 5 — NOTICE (всё нормально, но следует обратить внимание);
* 6 — INFO (информационное сообщение);
* 7 — DEBUG (отложенная печать).

### Полезные опции

По умолчанию если выхлоп идёт в консоль, а не перенаправляетя куда-то, journalctl использует указанный дефолтным pager, обычно это less.
Чтобы получить выхлоп напрямую в консоль, не используя pager, можно запустить его с параметром ==--no-pager==

```bash
journalctl --no-pager
```

Сам pager для systemd можно переопределить с помощью

```bash
export SYSTEMD_PAGER=more
```



### Вывод результата в другом, структурированном, формате. 

Для указания формата используем опцию -o.

Варианты доступных форматов:

* json — вывод данных в формате json для дальнейшего парсинга с помощью скриптов(python,perl) или обработки с помощью jq;
* json-pretty — то же, что и выше, но в данном случае json проходит pretty print, и представлен в более удобном для чтения человеком виде;
* json-sse — json c pretty print, представлен в более удобном для чтения человеком виде;
* cat —  сообщения из логов без служебных полей;
* export — бинарный формат, подходящий для экспорта или резервного копирования логов;
* short — формат вывода, аналогичный формату утилиты syslog;
* short-iso — формат вывода syslog с метками времени в формате ISO 8601;
* short-monotonic — формат вывода syslog c метками monotonic timestamp;
* short-precise — формат вывода syslog с метками точного времени (время событий указывается с точностью до микросекунд);
* verbose — максимально подробный формат представления данных, отображает даже те поля, которые в перечисленных выше форматах не отображаются.

Пример применения параметра -o:

```atop
journalctl  -u atop.service -o json
```

### Смотрим логи другой системы(скопировали каталог хранилища journald или смотрим логи в FAI из-под PXE)

К примеру, мы загрузили сервер с проблемой в другую систему с флешки/PXE, и хотим изучить его логи из системы, что мы используем для изучения и ремонта.
Корневую ФС изучаемого сервера мы, к примеру, смонтировали в каталог /target.

В таком случае записи из логов этой другой системы мы должны смотреть так


 ```bash
journalctl -D /target/var/log/journal -xe
```

Где после journalctl мы указываем параметр -D, или --directory с путём к каталогу хранилища journald, в нашем случае это /var/log/journal, а уже после – любые другие необходимые нам параметры, к примеру -xe, -b 1, -k и т.п.

## Определение объёма дискового пространства, занятого логами journalctl 

```bash
journalctl --disk-usage
```

## Ротация логов

По месту

```bash
sudo journalctl --vacuum-size=1G
```

По времени хранения логов
```bash
sudo journalctl --vacuum-time=1years
```

## Конфигурация journalctl

### Настройка записли логов systemd в соккет syslog

В /еtc/systemd/journald.conf указываем

```ini
ForwardToSyslog=yes
```

### Настройка ротации логов в конфигурацинном файле journald.conf

Также задать нужные нам параметры ротации логов можно в файле /еtc/systemd/journald.conf

* SystemMaxUse — максимальный объём, который логи могут занимать на диске;
* SystemKeepFree — объём свободного места, которое должно оставаться на диске после сохранения логов;
* SystemMaxFileSize — объём файла лога, по достижении которого он должен быть удален с диска;
* RuntimeMaxUse — максимальный объём, который логи могут занимать в файловой системе /run;
* RuntimeKeepFree — объём свободного места, которое должно оставаться в файловой системе /run после сохранения логов;
* RuntimeMaxFileSize — объём файла лога, по достижении которого он должен быть удален из файловой системы /run.


## Полезные материалы по теме
https://sematext.com/blog/journald-logging-tutorial/
https://shpargalki.org.ua/201/journalctl-how-to-search-in-the-log-errors-and-processes
https://tproger.ru/articles/useful-linux-commands/
https://habr.com/ru/post/503816/
https://habr.com/ru/company/southbridge/blog/315706/
https://sys-adm.in/os/nix/692-prosmotr-sobytij-journalctl-shpargalka.html
https://losst.ru/shpargalka-po-journalctl-v-linux
http://promaster.top/upravlenie-soobshhenijami-zhurnala-v-systemd-s-pomoshhju-journalctl-podrobnoe-rukovodstvo/
<https://habr.com/ru/company/selectel/blog/264731/>